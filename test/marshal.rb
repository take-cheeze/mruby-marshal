def strip_version(str)
  raise 'version error' unless
    str.length > 2 and str.getbyte(0) == 4 and str.getbyte(1) == 8
  str[2, str.length - 2]
end

def dump(v) strip_version Marshal.dump v end
def load(v) Marshal.load("\x04\x08" + v) end

def check_load_dump(obj, data)
  assert_equal data, dump(obj)
  assert_equal obj, load(data)
end

assert 'marshal io' do
  assert_equal({"hogehoge" => :hogehoge},
               Marshal.load(StringIO.new("\x04\x08{\x06\"\x0dhogehoge:\x0dhogehoge")))

  io = StringIO.new
  Marshal.dump({"hogehoge" => :hogehoge}, io)
  assert_equal "\x04\x08{\x06\"\x0dhogehoge:\x0dhogehoge", io.string
end

assert 'check marshal dump version' do
  assert_raise(TypeError) { Marshal.load("\x03\x08") }
  Marshal.dump(nil) == "\x04\x080"
end

assert 'marshal limit' do
  Marshal.dump({"hogehoge" =>  { :hogehoge => 0 }}, 3)
  assert_raise(ArgumentError) do
    Marshal.dump({"hogehoge" =>  { :hogehoge => 0 }}, 2)
  end
end

assert('Marshal.restore') {
  assert_nil Marshal.restore("\x04\x080")
}

assert('marshal true' ) { check_load_dump true , 'T' }
assert('marshal false') { check_load_dump false, 'F' }
assert('marshal nil') { check_load_dump nil, '0' }

assert('marshal symbol') { check_load_dump :hogehoge, ":\x0dhogehoge" }

assert('marshal fixnum') {
  result = true;
  {
    0 => "i\x00",
    1 => "i\x06",
    -1 => "i\xfa",
    124 => "i\x01\x7c",
    256 => "i\x02\x00\x01",
    -125 => "i\xff\x83",
    -254 => "i\xff\x02",
    -255 => "i\xff\x01",
    -256 => "i\xff\x00",
    -257 => "i\xfe\xff\xfe",
  }.each { |k,v| result = result and check_load_dump(k, v) }
}

assert("marshal string") {
  check_load_dump "hogehoge", "\"\x0dhogehoge"
}

class StringSub < String
end

class HashSubIV < Hash
  def initialize(obj)
    super obj
    @val = "foo"
    self["val"] = nil
  end
end

assert('marshal subclass of string') {
  check_load_dump StringSub.new('foo'), "C:\x0eStringSub\"\x08foo"
}
assert('marshal subclass of hash with instance variable') {
  check_load_dump(HashSubIV.new('foo'),
                  "IC:\x0eHashSubIV}\x06\"\x08val0\"\x08foo\x06:\x09@val\"\x08foo")
}

assert("marshal regexp") {
  check_load_dump(/hogehoge/, "/\x0dhogehoge\x00")
} if Object.const_defined? :Regexp

assert('marshal array') {
  check_load_dump ["hogehoge", :hogehoge], "[\x07\"\x0dhogehoge:\x0dhogehoge"
}

assert('marshal hash') {
  check_load_dump({"hogehoge" => :hogehoge}, "{\x06\"\x0dhogehoge:\x0dhogehoge")
}

assert('marshal hash with default') {
  h = Hash.new true
  h["hoo"] = "boo"
  check_load_dump h, "}\x06\"\x08hoo\"\x08booT"
}

assert 'marshal float' do
  check_load_dump 1.0, "f\x061"
end

assert 'marshal link' do
  check_load_dump({ :b => [4, 5, 1.0, 2, 2, 1.0] }, "{\x06:\x06b[\vi\ti\nf\x061i\ai\a@\a")
  # check_load_dump({ :a => [1.0, 2, 3, 2], :b => [4, 5, 1.0, 2, 2] },
  #                 "{\a:\x06a[\tf\x061i\ai\bi\a:\x06b[\ni\ti\n@\ai\ai\a")
end

assert 'ignore encoding instance variable of string' do
  # load `Marshal.dump 'test'` generated by CRuby with encoding
  assert_equal ['test'], Marshal.load("\x04\b[\x06I\"\ttest\x06:\x06ET")
end

assert 'marshal Struct' do
  Struct.new 'StructTest', :a, :b
  tmp = Struct::StructTest.new :aa, :bb

  check_load_dump tmp, "S:\x17Struct::StructTest\a:\x06a:\aaa:\x06b:\abb"
  tmp = Marshal.dump tmp
  Struct.__send__ :remove_const, :StructTest

  # struct Struct::StructTest not compatible (struct size differs)
  assert_raise TypeError do
    Struct.new 'StructTest', :a, :b, :c
    Marshal.load tmp
  end
  Struct.__send__ :remove_const, :StructTest

  # struct Struct::StructTest not compatible (:b for :c)
  assert_raise TypeError do
    Struct.new 'StructTest', :a, :c
    Marshal.load tmp
  end
  Struct.__send__ :remove_const, :StructTest
end

assert 'marshal user defined instance' do
  class B
    def initialize
      @a = 3
    end

    attr_reader :a
    def == o; @a == o.a end
  end
  check_load_dump B.new, "o:\x06B\x06:\a@ai\b"
end

assert 'marshal class inside module' do
  module ModTest
    module A
      C = 10

      class B
      end
    end
  end

  expected = "\004\bo:\x12ModTest::A::B\x00"
  assert_equal expected, Marshal.dump(ModTest::A::B.new)
  assert_equal ModTest::A::B, Marshal.load(expected).class

  assert_raise(TypeError) { Marshal.load "\004\bo:\x12ModTest::A::C\x00" }
  assert_raise(ArgumentError) { Marshal.load "\004\bo:\x12ModTest::A::D\x00" }
end

assert 'C API' do
  test_str = "\x04\b\"\x00"
  assert_equal test_str, Marshal.mrb_marshal_dump("")
  assert_equal "", Marshal.mrb_marshal_load(test_str)
end

assert 'user defined marshal method' do
  class BinaryDumper
    def _dump a = 0; 'test' end
    def self._load str, a = 0
      assert_equal 'test', str
      BinaryDumper.new
    end
    def == o; o.kind_of? BinaryDumper end
  end
  check_load_dump BinaryDumper.new, "u:\x11BinaryDumper\ttest"

  class ObjectDumper
    def marshal_dump a = 0; 'test' end
    def self.marshal_load str, a = 0
      assert_equal 'test', str
      ObjectDumper.new
    end
    def == o; o.kind_of? ObjectDumper end
  end
  check_load_dump ObjectDumper.new, "U:\x11ObjectDumper\"\ttest"
end

assert '#21' do
  check_load_dump [:one, :two, :three], "[\b:\bone:\btwo:\nthree"
end

assert '#29' do
  skip

  class MarshalTest
    def initialize
      @a = 0.1
      @b = 0.2
      @c = 0.3
    end

    attr_reader :a, :b, :c

    def == o; self.a == o.a and self.b == o.b and self.c == o.c end
  end

  check_load_dump MarshalTest.new, "o:\x10MarshalTest\b:\a@af\b0.1:\a@bf\b0.2:\a@cf\b0.3"
end
